## AI Browser Agent (LLM‑управляемый браузерный агент)

**AI Browser Agent** — это vision‑ориентированный агент, который с помощью LLM (GPT‑4o через OpenRouter) автоматически управляет браузером, выполняет сложные многошаговые сценарии на сайтах и умеет извлекать данные со страниц.

Агент:
- **Автоматизирует действия в браузере**: переход по ссылкам, клики, ввод текста, скроллинг, ожидания
- **Анализирует скриншоты страниц** и принимает решения по визуальному контексту (без прямого парсинга DOM)
- **Маркирует интерактивные элементы** на странице (inputs, links, buttons) цветом и номером для удобства выбора
- **Сохраняет историю действий и сессию браузера** (cookies, авторизация между запусками)
- **Извлекает и сохраняет данные** (например, результаты поиска, карточки товаров, вакансии) в файл

Типичный сценарий использования: «Зайди на сайт, найди X, отфильтруй по Y, открой нужные страницы и извлеки данные в структурированном виде».

---

### Содержание

- **Описание**
- **Стек и технологии**
- **Требования**
- **Установка**
- **Конфигурация (`.env`)**
- **Запуск и использование**
- **Поддерживаемые действия агента**
- **Архитектура проекта**
- **Рекомендации по разработке**
- **Вопросы и отладка**
- **Планы по улучшению**

---

### Описание

Проект реализует **браузерного агента**, который:

- запускает Chromium через Playwright;
- делает скриншоты текущей страницы;
- подсвечивает интерактивные элементы и нумерует их на странице через встроенный JS‑скрипт;
- отправляет скриншот и состояние браузера в LLM;
- получает от модели **структурированную команду** (например, «кликни по элементу №5», «напечатай этот текст», «проскроль страницу вниз», «перейди на URL»);
- исполняет команду и повторяет цикл, пока задача не будет завершена или помечена как неудачная.

Таким образом, LLM получает возможность **пошагово управлять браузером**, опираясь на визуальное представление страницы и историю прошлых действий.

---

### Стек и технологии

- **Язык**: Python 3.x (асинхронный, `asyncio`)
- **Браузерная автоматизация**: `playwright` (Chromium)
- **LLM‑клиент**: `openai` (AsyncOpenAI) через **OpenRouter API** (`https://openrouter.ai/`)
  - Модель по умолчанию: **`gpt-4o`** (vision‑модель)
- **Конфигурация и модели данных**:
  - `pydantic`
  - `pydantic-settings`
- **JavaScript**:
  - `app/scripts/mark_page.js` — скрипт для визуальной маркировки элементов на странице

Проект использует **structured output**: ответ модели парсится в Pydantic‑модель `AgentAction`, что делает поведение агента предсказуемым и удобным для отладки.

---

### Требования

- **Python**: 3.10+ (рекомендовано)
- **Операционная система**: Windows / Linux / macOS с поддержкой Chromium
- **Интернет‑доступ** к OpenRouter API
- **Установленные браузеры Playwright (Chromium)**

Пример минимального набора Python‑зависимостей (рекомендуется оформить в `requirements.txt`):

```txt
playwright
openai
pydantic
pydantic-settings
```

---

### Установка

1. **Клонировать репозиторий**

```bash
git clone <URL_ВАШЕГО_РЕПОЗИТОРИЯ>
cd ai-browser-agent-user
```

2. **Создать и активировать виртуальное окружение (рекомендуется)**

```bash
python -m venv .venv
.venv\Scripts\activate        # Windows
# или
source .venv/bin/activate     # Linux/macOS
```

3. **Установить зависимости Python**

Если вы создали `requirements.txt`:

```bash
pip install -r requirements.txt
```

Либо установить пакеты напрямую:

```bash
pip install playwright openai pydantic pydantic-settings
```

4. **Установить браузеры Playwright**

```bash
playwright install chromium
```

---

### Конфигурация (`.env`)

Все настройки загружаются через `pydantic-settings` из файла `.env` в корне проекта.

Создайте файл `.env` рядом с `main.py` со следующим содержимым (пример):

```env
OPENAI_API_KEY=sk-or-v1-...        # API‑ключ для OpenRouter (обязательно)
MODEL_NAME=gpt-4o                  # Имя модели LLM (по умолчанию: gpt-4o)
HEADLESS=False                     # Запуск браузера: False — с окном, True — без окна
SESSION_FILE=auth.json             # Файл для сохранения сессии браузера (cookies и авторизация)
```

- **`OPENAI_API_KEY`** — получите на сайте [OpenRouter](https://openrouter.ai/).
- **`HEADLESS`**:
  - для разработки удобно `False` (браузер виден);
  - для автоматизированного/серверного запуска можно использовать `True`.
- **`SESSION_FILE`** — путь к JSON‑файлу с сессией; между запусками вы сможете сохранять авторизацию (например, логин на сайтах).

Файлы `.env` и `auth.json` должны быть добавлены в `.gitignore` (секреты и приватные данные не должны попадать в репозиторий).

---

### Запуск и использование

1. Убедитесь, что:
   - установлен Python и зависимости;
   - установлен Chromium через Playwright;
   - корректно заполнен `.env` с действительным `OPENAI_API_KEY`.

2. Запустите приложение:

```bash
python main.py
```

3. В консоли будет предложено ввести **задачу** для агента, например:

```text
Найди вакансии Python‑разработчика на hh.ru, открой подходящие предложения и извлеки название вакансии, компанию и ссылку.
```

4. Агент:
   - откроет стартовую страницу (по умолчанию `https://ya.ru`);
   - будет выполнять шаги (поиск, переходы по ссылкам, ввод текста, скролл и т.п.);
   - по мере необходимости будет создавать новые вкладки и переключаться на них;
   - при запросе на извлечение данных сохранит результат в `result.txt`.

5. После завершения задачи агент либо:
   - выполнит действие `finish` (успешное завершение), либо
   - выполнит действие `fail` с описанием причины.

---

### Поддерживаемые действия агента

LLM возвращает структурированную команду в виде модели `AgentAction`. Основные типы действий:

- **`click`** — клик по элементу с указанным `element_id` (выбранному из размеченных на странице элементов)
- **`type`** — ввод текста в поле ввода (`element_id` + `text_input`)
- **`scroll`** — прокрутка страницы (вниз/вверх)
- **`goto`** — переход по указанному URL
- **`wait`** — подождать некоторое время (используется, чтобы дождаться загрузки страницы/динамики)
- **`extract`** — извлечь содержимое/данные со страницы и сохранить в файл (`result.txt`)
- **`finish`** — успешное завершение сценария
- **`fail`** — завершение с ошибкой (например, цель недостижима)

Помимо `action_type`, модель включает:

- **`reasoning`** — объяснение, почему выбранное действие уместно на этом шаге
- **`element_id`** — идентификатор размеченного элемента на странице
- **`text_input`** — текст, который нужно ввести (если применимо)
- **`extracted_content`** — извлечённые данные (для `extract`)
- **`url`** — адрес для перехода (для `goto`)
- **`current_phase`** — текущая фаза state‑machine (см. ниже)

---

### Архитектура проекта

Упрощённая структура:

```text
ai-browser-agent-user/
├── main.py                    # Точка входа в приложение
├── screenshot.png             # Текущий скриншот страницы (runtime‑файл)
├── result.txt                 # Файл с извлечёнными результатами
├── app/
│   ├── agent.py              # Класс BrowserAgent: оркестратор логики агента
│   ├── config.py             # Загрузка настроек из .env (Settings)
│   ├── services/
│   │   ├── browser.py        # BrowserService: обёртка над Playwright
│   │   ├── llm.py            # LLMService: общение с OpenRouter/OpenAI API
│   │   └── models.py         # Pydantic‑модели (AgentAction и др.)
│   └── scripts/
│       └── mark_page.js      # JS‑скрипт разметки элементов на странице
└── .gitignore
```

- **`main.py`**
  - создаёт экземпляр `BrowserAgent`;
  - запрашивает у пользователя формулировку задачи;
  - инициирует основной цикл работы агента.

- **`app/agent.py` (`BrowserAgent`)**
  - координирует:
    - запуск/остановку браузера (`BrowserService`);
    - взаимодействие с LLM (`LLMService`);
    - главный цикл: *сделать скриншот → разметить элементы → отправить в LLM → выполнить действие*;
  - хранит историю последних шагов (для контекста LLM);
  - управляет finite‑state‑machine (фазы вроде SEARCHING, SELECTING, VIEWING, EXTRACTING, DONE).

- **`app/services/browser.py` (`BrowserService`)**
  - управляет Chromium через Playwright;
  - загружает и сохраняет сессию (`auth.json`);
  - отвечает за:
    - `start()` / `stop()` — запуск и завершение браузера и контекста;
    - `goto(url)` — переход на указанный адрес;
    - `mark_page()` — вызов JS‑скрипта `mark_page.js` для визуальной разметки элементов и формирования массива `window.aiElements`;
    - отслеживание новых вкладок и переключение на них.

- **`app/services/llm.py` (`LLMService`)**
  - кодирует скриншоты (PNG) в base64;
  - формирует prompt для LLM, включая:
    - текущее состояние state‑machine;
    - историю предыдущих действий;
    - список размеченных элементов страницы (ids, типы, описания);
  - вызывает OpenRouter / OpenAI API для получения ответа;
  - парсит ответ в Pydantic‑модель `AgentAction` (structured output).

- **`app/services/models.py`**
  - определяет `AgentAction` и другие связанные структуры;
  - отвечает за валидацию формата ответов модели.

- **`app/scripts/mark_page.js`**
  - выполняется в контексте страницы через `page.evaluate`;
  - находит интерактивные элементы (`input`, `textarea`, `button`, `a` и т.п.);
  - подсвечивает их:
    - **синим** — input‑элементы;
    - **красным** — ссылки и кнопки;
  - добавляет к ним нумерацию и сохраняет информацию в глобальный массив `window.aiElements`.

---

### Рекомендации по разработке

- **Структура зависимостей**
  - Создайте файл `requirements.txt` и поддерживайте его в актуальном состоянии.
  - При необходимости добавьте `pyproject.toml`/Poetry для более строгого управления зависимостями.

- **Конфигурация**
  - Вынесите все чувствительные данные и настройки в `.env` (не коммитьте в репозиторий).
  - При желании добавьте `(.env.example)` с примером значений (без секретов).

- **Тестирование**
  - Добавьте модульные тесты для сервисов `LLMService` и `BrowserService` (моки для API и браузера).

- **Инфраструктура**
  - Можно добавить `Dockerfile` для удобной контейнеризации и развёртывания.

---

### Вопросы и отладка

- **Браузер не запускается / ошибки Playwright**
  - Убедитесь, что вы выполнили `playwright install chromium`.
  - Проверьте, что у процесса достаточно прав для запуска браузера (антивирусы и политики безопасности могут блокировать).

- **Ошибки авторизации или 401/403 от OpenRouter**
  - Проверьте корректность `OPENAI_API_KEY` в `.env`.
  - Убедитесь, что ключ активен и имеет доступ к модели `gpt-4o`.

- **Агент «зависает» или долго ничего не делает**
  - Логика предусматривает ожидания (`wait`) и задержки (`asyncio.sleep(3)` между шагами).
  - Посмотрите логи/вывод в консоль, чтобы понять, какую команду сейчас выполняет агент.

- **Результаты записываются в `result.txt` бесконечно**
  - Файл открывается в режиме `append`; периодически очищайте или ротуйте его.

---

### Планы по улучшению

- Добавить:
  - `requirements.txt` и/или `pyproject.toml`;
  - пример файла `.env.example`;
  - тесты для основных сервисов;
  - Docker‑окружение для быстрого старта.
- Расширить:
  - набор поддерживаемых действий агента;
  - обработку ошибок сети и API;
  - логику работы state‑machine (например, специальные режимы для форм/таблиц).

Если вы планируете публиковать проект как open‑source, дополнительно добавьте:

- файл `LICENSE` с выбранной лицензией (например, MIT);
- раздел **Contributing** с правилами для внешних контрибьюторов.

